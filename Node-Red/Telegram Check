#
#https://github.com/Techserv-krY/EnOcean_ESP8266_Gateway/wiki/New-way-to-split-Telegram-and-check-and-cut-Multitelegram-and-Response-in-Node-Red
#Check response telegram / crc check / send out ( shield oder device ) to mysql
#
// Funktion zum Extrahieren von Nachrichten aus Rohdaten mit Hilfe von Rekursion
function extractMessages(data, currentIndex, messages) {
    // Wenn der aktuelle Index größer oder gleich der Datenlänge ist, geben die Nachrichten zurück
    if (currentIndex >= data.length) {
        return messages;
    }

    // Suche den Start der Nachricht
    const messageStart = data.findIndex((byte, index) => byte === 85 && index >= currentIndex);
    // Wenn keine Nachricht gefunden wurde, gib die Nachrichten zurück
    if (messageStart === -1) {
        return messages;
    }

    // Suche den Start der nächsten Nachricht
    const nextMessageStart = data.findIndex((byte, index) => byte === 0x55 && index > messageStart);
    // Wenn keine nächste Nachricht gefunden wurde, setze das Nachrichtenende auf die Datenlänge
    const messageEnd = nextMessageStart === -1 ? data.length : nextMessageStart;
    // Extrahiere die Nachricht
    const message = data.slice(messageStart, messageEnd);

    // Rufe die Funktion rekursiv auf, um weitere Nachrichten zu extrahieren
    return extractMessages(data, messageEnd, [...messages, message]);
}

// CRC-8 Funktion zur Berechnung der Prüfsumme
function crc8(data) {
    const POLYNOM = 0x07;
    let crc = 0;

    // Berechne die CRC-8 Prüfsumme
    for (const byte of data) {
        crc ^= byte;
        for (let i = 0; i < 8; i++) {
            const carry = crc & 0x80;
            crc = (crc << 1) & 0xFF;
            if (carry) {
                crc ^= POLYNOM;
            }
        }
    }

    return crc;
}

// Funktion zum Parsen eines EnOcean-Telegramms
function parseEnOceanTelegram(telegram) {
    // Extrahiere die relevanten Teile des Telegramms
    const syncByte = telegram[0];
    const dataLength = (telegram[1] << 8) | telegram[2];
    const optionalLength = telegram[3];
    const packetType = telegram[4];
    const crc8Header = telegram[5];
    const data = telegram.slice(6, 6 + dataLength);
    const optionalData = telegram.slice(6 + dataLength, 6 + dataLength + optionalLength);
    const crc8Data = telegram[telegram.length - 1];

    // Berechne die CRC-8 Prüfsumme für den Header und die Daten
    const header = telegram.slice(1, 5);
    const calculatedCrc8Header = crc8(header);
    const headerCrcOk = calculatedCrc8Header === crc8Header;

    const calculatedCrc8Data = crc8([...data, ...optionalData]);
    const dataCrcOk = calculatedCrc8Data === crc8Data;

    // Gib das geparste Telegramm und den CRC-Status zurück
    return {
        syncByte,
        dataLength,
        optionalLength,
        packetType,
        crc8Header,
        data,
        optionalData,
        crc8Data,
        headerCrcOk,
        dataCrcOk,
    };
}

// Funktion zum Senden des geparsten Telegramms
function send_out(parsedTelegram, _msgid) {
    const { syncByte, dataLength, optionalLength, packetType, crc8Header, data, optionalData, crc8Data, headerCrcOk, dataCrcOk } = parsedTelegram;
    let newMsg = { _msgid: _msgid };
    newMsg.payload = {
        syncByte,
        dataLength,
        optionalLength,
        packetType,
        crc8Header,
        data,
        optionalData,
        crc8Data,
        headerCrcOk,
        dataCrcOk
    };

    // Überprüfe, ob ein neuer Shield gefunden wurde. Wenn ja, füge ihn in SQL ein, sonst wähle aus
    if (data[0] === 0x00 && data[1] === 0xff) {
        let device = Buffer.from(data.slice(1), "hex").toString("hex");
        newMsg.topic = "INSERT IGNORE INTO `node_eno_shields` (`created`, `modified`, `shield`) VALUES ( now(), now(), '" + device + "'); select * from `node_eno_shields` where shield = '" + device + "'";
        newMsg.telegram = { "DeviceID": device, "Data": data, "OptData": optionalData };
    } else { // Wenn ein neues Gerät gefunden wurde, füge es in SQL ein, sonst wähle aus
        let deviceBytes = data.slice((dataLength - 5), -1);
        let device = Buffer.from(deviceBytes, "hex").toString("hex");
        if (deviceBytes[0] !== 0xff && device.length !== 0) { // Länge = Überprüfung für Antwort-Telegramm - wir brauchen sie nicht
            newMsg.topic = "INSERT IGNORE INTO `node_eno_devices` (`created`, `modified`, `deviceid`) VALUES ( now(), now(), '" + device + "'); SELECT `node_eno_devices`.* , `node_eno_shields`.`build`, `node_eno_shields`.`floor`, `node_eno_shields`.`room`, `node_eno_shields`.`ip` FROM `node_eno_devices` INNER JOIN `node_eno_shields` ON `node_eno_devices`.`shield` = `node_eno_shields`.`shield` WHERE `deviceid` = '" + device + "'";
            newMsg.telegram = { "DeviceID": device, "Data": data, "OptData": optionalData };
        } else {
            if (device.length === 0) { // Für Debug-Antwort
                node.warn("Debug Response");
                node.error(parsedTelegram);
                return;
            } else {
                return;
            }
        }
    }
    node.send(newMsg, false);
    return;
}

// Ersetze rawData durch die tatsächlichen Eingangsdaten in deinem Node-RED-Flow
const rawData = msg.payload;

// Extrahiere die Nachrichten aus den Rohdaten
const messages = extractMessages(rawData, 0, []);

// Verarbeite und sende jede Nachricht separat mit der ursprünglichen msg.id
messages.forEach(message => {
    const parsedTelegram = parseEnOceanTelegram(message);

    if (!parsedTelegram.headerCrcOk || !parsedTelegram.dataCrcOk) {
        const crcErrors = [];
        if (!parsedTelegram.headerCrcOk) crcErrors.push("header");
        if (!parsedTelegram.dataCrcOk) crcErrors.push("data");
        const errorMessage = `Wrong CRC for ${crcErrors.join(" and ")} in telegram: ${JSON.stringify(message)}`;
        node.error(errorMessage);
    } else {
        // Rufe die send_out-Funktion mit dem geparsten Telegram auf
        send_out(parsedTelegram, msg._msgid);
    }
});
return;
